<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cartographie TRACC</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <link rel="stylesheet" href="style.css">

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="data-SNCF/lignesrfn.geojson.js"></script>
</head>

<body>
    <header>
        <h1>SNCF TRACC View
            <span id="infoBtn" title="Informations">
                ℹ️
            </span>
        </h1>
    </header>

    <!-- Rubrique réseau à gauche -->
    <aside id="SelectionReseau">
        <h2>Réseau</h2>
        <!-- Checkbox du réseau national -->
        <form>
            <label><input type="checkbox" id="checkboxLignes" checked> Lignes du réseau national</label><br>
            <!-- Sélection de l'infrastructure à afficher -->
            <label for="infraSelect" style="margin-bottom: -5px;"><strong>Infrastructures à afficher
                    :</strong></label><br>
            <select id="infraSelect" style="width: 100%; margin-top: 5px;">
                <option value="" name="infra"> Sélectionner </option>
                <option value="gares" name="infra">Gares</option>
                <option value="ouvrages" name="infra">Ouvrages en terre</option>
                <option value="ponts_route" name="infra">Ponts-route</option>
                <option value="passerelles" name="infra">Passerelles</option>
            </select>
        </form>
        <!-- Résultat des infrastructures à risque-->
        <div id="resultatsOuvrages" style="margin-top: 15px; align-items: center;">
            <div id="OuvragesArisqueDetecte" style="font-weight:bold">Infrastructures à risque :</div>
            <div id="nombreOuvrages" style="font-weight:bold"></div>
            <div id="nomsOuvrages">
                <ul id="listeOuvrages"></ul>
            </div>
        </div>
    </aside>

    <!-- Carte au centre -->
    <div id="map"></div>

    <!-- Rubrique scénarios à droite -->
    <!-- Sélection des scénarios -->
    <aside id="SelectionScenarios">
        <button id="clearcarte" style="width:230px; margin-bottom: 20px;">Nettoyer la carte</button>
        <h2>Scénarios climatiques</h2>
        <form>
            <label class="scenario-label">
                <input type="radio" name="scenario" value="actuel"> Référence
                <div class="scenario-explication">Période de référence : 1976–2005</div>
            </label>

            <label class="scenario-label">
                <input type="radio" name="scenario" value="2030"> Horizon 2030
                <div class="scenario-explication">Monde ➞ +1.5°C / <strong>France ➞ +2°C</strong></div>
            </label>

            <label class="scenario-label">
                <input type="radio" name="scenario" value="2050"> Horizon 2050
                <div class="scenario-explication">Monde ➞ +2°C / <strong>France ➞ +2,7°C</strong></div>
            </label>

            <label class="scenario-label">
                <input type="radio" name="scenario" value="2100"> Horizon 2100
                <div class="scenario-explication">Monde ➞ +3°C / <strong>France ➞ +4°C</strong></div>
            </label>

        </form>

        <!-- Sélection des indices -->
        <h3>Indice à afficher</h3>
        <select id="indiceSelect">
            <option value=""> Sélectionner </option>
            <option value="ZonesInnondables">Zones innondables</option>
            <option value="TXm_seas_JJA">Température maximale en été (°C)</option>
            <option value="TMm_seas_JJA">Température moyenne en été (°C)</option>
            <option value="TX35D_yr">Jours ≥ 35°C</option>
            <option value="TX30D_yr">Jours ≥ 30°C</option>
            <option value="Rx1d_yr">Max pluie extrême (mm)</option>
            <option value="RRq99_yr">Pluies extrêmes (mm)</option>
            <option value="RRq99refD_yr">Fréquence pluie remarquable (j)</option>
            <option value="IFM40_yr">Feux météo (j)</option>
            <option value="SWI04_yr">Humidité des sols (SWI04)</option>
            <option value="DebHyd">Débit hydrologique (m³/s)</option>
        </select>

        <div id="probabiliteContainer" style="display: none; margin-top: 10px;">
            <label for="probabiliteSelect">
                <h3>Probabilité de l'innondation :</h3>
            </label>
            <select id="probabiliteSelect" style="width: 100%;">
                <option value="">Sélectionner</option>
                <option value="Forte">Forte probabilié</option>
                <option value="Moyenne">Moyenne probabilité</option>
                <option value="Faible">Faible probabilité</option>
            </select>
        </div>

        <div id="saisonContainer" style="display: none; margin-top: 10px;">
            <label for="saisonSelect">
                <h3>Saison hydrologique :</h3>
            </label>
            <select id="saisonSelect" style="width: 100%;">
                <option value="">Sélectionner</option>
                <option value="Été">Été</option>
                <option value="Automne">Automne</option>
                <option value="Hiver">Hiver</option>
                <option value="Printemps">Printemps</option>
            </select>
        </div>




        <!-- Texte explicatif des indices-->

        <div id="explicationIndice" class="texte-explicatif"
            style="margin-top: 10px; margin-bottom: 10px;font-size: 0.9em; font-style: italic; color: #333;">
        </div>

        <!-- Solution temporaire pour le croisement des données -->
        <div id="datacrossContainer" style="display: block; margin-top: 10px;">
            <label for="datacrossSelect">
                <h4 id="croiseavec" style="display: none; margin-top: 0px;">Croisé avec :</h4>
            </label>
            <select id="datacrossSelect" style="width: 100%;">
                <option value=""> Croiser les données </option>
                <option value="ZonesInnondables">Zones innondables</option>
                <option value="TXm_seas_JJA">Température maximale en été (°C)</option>
                <option value="TMm_seas_JJA">Température moyenne en été (°C)</option>
                <option value="TX35D_yr">Jours ≥ 35°C</option>
                <option value="TX30D_yr">Jours ≥ 30°C</option>
                <option value="Rx1d_yr">Max pluie extrême (mm)</option>
                <option value="RRq99_yr">Pluies extrêmes (mm)</option>
                <option value="RRq99refD_yr">Fréquence pluie remarquable (j)</option>
                <option value="IFM40_yr">Feux météo (j)</option>
                <option value="SWI04_yr">Humidité des sols (SWI04)</option>
                <option value="DebHyd">Débit hydrologique (m³/s)</option>
            </select>
        </div>

        <!-- Texte explicatif des 2èmes indices-->

        <div id="explicationIndice2" class="texte-explicatif"
            style="margin-top: 10px; margin-bottom: 10px;font-size: 0.9em; font-style: italic; color: #333;">
        </div>

        <!-- Texte explicatif du seuil-->
        <h3 id="labelseuil">Seuil de risque </h3><span id="explication_seuil" class="texte-explicatif"
            style="margin-top: 0px; font-size: 0.9em; font-style: italic; color: #333;">Indiquez une valeur de seuil
            concernant l'indice sélectionné pour afficher les infrastructures que vous définissez à risque</span>
        <div id="seuilContainer">
            <input type="number" id="seuilValue" value="0" style="width: 60px; margin-left: 20px;">
            <button id="afficherBtn" style="margin-left: 30px;">Afficher</button>

    </aside>

    <div id="modalIntro" class="modal">
        <div class="modal-content">
            <h2>Bienvenue sur SNCF TRACC View</h2>
            <p>
                SNCF TRACC View est un outil pédagogique et décisionnel permettant de visualiser et d'anticiper les
                impacts du changement climatique sur les infrastructures ferroviaires. <br>
                <br><em>(TRACC : trajectoire de réchauffement de référence pour l'adaptation au changement
                    climatique)</em>
            </p>
            <p>
                Cette application interactive vous permet :
            <ul>
                <li>D'explorer les risques climatiques selon différents <strong>scénarios TRACC</strong>.</li>
                <li>De visualiser plusieurs <strong>indices d'aléas climatiques</strong>.</li>
                <li>De cibler différents <strong>types d'infrastructures</strong>.</li>
                <li>De définir un <strong>seuil de risque personnalisé</strong>.</li>
            </ul>
            </p>
            <p><em>Sources : DRIAS-climat, DRIAS-eau, SNCF Open Data, GeoRisque.gouv</em></p>
            <button id="closeModalBtn">Accéder à l'application</button>
        </div>
    </div>

    <script>
        //Centrer la carte sur la France
        const carte = L.map('map').setView([47.07, 2.02], 5.5);
        //Ajouter le fond de carte d'OpenStreetMap
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {
            foo: 'bar',
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(carte);

        // Création d'un Pane et attribution d'une priorité dans la visualisation (Z=650, 450 par défaut) utilisé pour le rfn
        carte.createPane('reseauPane');
        carte.getPane('reseauPane').style.zIndex = 650;

        // Création d'un Pane et attribution d'une priorité dans la visualisation (Z=650, 450 par défaut) utilisé pour les infrastructures à risque
        carte.createPane('infraPane');
        carte.getPane('infraPane').style.zIndex = 800;

        // Ajout du pane pour les scénarios
        carte.createPane('scenarioPane');
        carte.getPane('scenarioPane').style.zIndex = 400;

        // On met le pane des popups au dessus des autres pour qu'il soient visibles 
        carte.getPane('popupPane').style.zIndex = 1000;

        // Fonction qui permet de renvoyer une couleur sur une palette allant de couleur min à couleur max, associées à une valeur min et valeur max
        function getColor(val, min, max, colorMin, colorMax) {
            // Convertir les couleurs hexadécimales en RGB
            function hexToRgb(hex) {
                hex = hex.replace('#', '');
                if (hex.length === 3) {
                    hex = hex.split('').map(c => c + c).join('');
                }
                const bigint = parseInt(hex, 16);
                return {
                    r: (bigint >> 16) & 255,
                    g: (bigint >> 8) & 255,
                    b: bigint & 255
                };
            }

            // Convertir RGB en couleur hexadécimale
            function rgbToHex(r, g, b) {
                return "#" + [r, g, b].map(x => {
                    const hex = Math.round(x).toString(16);
                    return hex.length === 1 ? "0" + hex : hex;
                }).join('');
            }

            // Insérer val dans [min, max]
            const ratio = Math.max(0, Math.min(1, (val - min) / (max - min)));
            const c1 = hexToRgb(colorMin);
            const c2 = hexToRgb(colorMax);
            const r = c1.r + (c2.r - c1.r) * ratio;
            const g = c1.g + (c2.g - c1.g) * ratio;
            const b = c1.b + (c2.b - c1.b) * ratio;
            return rgbToHex(r, g, b);
        }

        // La position en degré des valeurs ne permet pas un rendu propre sans conversion en mètres
        // Fonction pour approx. la distance en degrés correspondant à un côté de N mètres
        function metersToDegreesLat(meters) {
            return meters / 111320; // 1° lat ~ 111.32 km
        }

        function metersToDegreesLon(meters, latitude) {
            return meters / (40075000 * Math.cos(latitude * Math.PI / 180) / 360); // dépend de la latitude
        }

        // Fonction pour créer un carré en mètres 
        function getSquareAround(lat, lon, meters = 5000) {
            const dLat = metersToDegreesLat(meters) / 2;
            const dLon = metersToDegreesLon(meters, lat) / 2;
            return [
                [lat - dLat, lon - dLon],
                [lat - dLat, lon + dLon],
                [lat + dLat, lon + dLon],
                [lat + dLat, lon - dLon],
                [lat - dLat, lon - dLon]
            ];
        }

        let scenarioLayerGroup = null; // Pour stocker la couche affichée
        // Ajout d'une légende à la carte
        const legend = L.control({ position: 'bottomright' });

        legend.onAdd = function (map) {
            this._div = L.DomUtil.create('div', 'custom-legend');
            this.update();
            return this._div;
        };

        //     legend.update = function (props) {
        //         if (!props) {
        //             this._div.innerHTML = '';
        //             return;
        //         }

        //         const { id_indice, min, max, colorMin, colorMax } = props;

        //         // Sauvegarder la valeur actuelle si slider déjà présent
        //         const existingSlider = document.getElementById("seuilSlider");
        //         let currentValue = min;
        //         if (existingSlider) {
        //             currentValue = existingSlider.value;
        //             // Optionnel : vérifie que la valeur est toujours dans la plage min/max
        //             if (currentValue < min) currentValue = min;
        //             if (currentValue > max) currentValue = max;
        //         }

        //         this._div.innerHTML = `
        //     <div class="legend-bar-container">
        //         <span class="legend-max">${max.toFixed(1)}</span>
        //         <div class="legend-bar">
        //             <input type="range" id="seuilSlider" min="${min}" max="${max}" step="0.1" value="${currentValue}" orient="vertical">
        //         </div>
        //         <span class="legend-min">${min.toFixed(1)}</span>
        //     </div>
        //     <div class="valeur-seuil">
        //         <span id="valeurSlider">${currentValue}</span>
        //     </div>
        // `;

        //         // Appliquer les couleurs au dégradé
        //         const legendBar = this._div.querySelector(".legend-bar");
        //         legendBar.style.background = `linear-gradient(to bottom, ${colorMax}, ${colorMin})`;


        //         // Synchronisation slider ↔ input
        //         const slider = document.getElementById("seuilSlider");

        //         // Empêche la carte de bouger quand on clique ou glisse sur le slider
        //         L.DomEvent.disableClickPropagation(slider);
        //         L.DomEvent.disableScrollPropagation(slider);

        //         const output = document.getElementById("valeurSlider");
        //         const seuilInput = document.getElementById("seuilValue");

        //         slider.addEventListener("input", () => {
        //             output.textContent = slider.value;
        //             seuilInput.value = slider.value;
        //         });

        //         seuilInput.addEventListener("input", () => {
        //             const val = parseFloat(seuilInput.value);
        //             if (!isNaN(val) && val >= min && val <= max) {
        //                 slider.value = val;
        //                 output.textContent = val;
        //             }
        //         });
        //     };

        legend.update = function (props) {
            if (!props) {
                this._div.innerHTML = '';
                return;
            }

            const existingSlider = document.getElementById("seuilSlider");
            let currentValue = props.min ?? 0;
            if (existingSlider) {
                currentValue = existingSlider.value;
                if (currentValue < props.min) currentValue = props.min;
                if (currentValue > props.max) currentValue = props.max;
            }

            // Légende classique dégradée
            if (!props.Q1) {
                const { min, max, colorMin, colorMax } = props;

                this._div.innerHTML = `
            <div class="legend-bar-container">
                <span class="legend-max">${max.toFixed(1)}</span>
                <div class="legend-bar" style="background: linear-gradient(to bottom, ${colorMax}, ${colorMin});">
                    <input type="range" id="seuilSlider" min="${min}" max="${max}" step="0.1" value="${currentValue}" orient="vertical">
                </div>
                <span class="legend-min">${min.toFixed(1)}</span>
            </div>
            <div class="valeur-seuil">
                <span id="valeurSlider">${currentValue}</span>
            </div>
        `;
            }

            // Légende en quartiles (4 couleurs sans dégradé)
            else {
                const { min, max, Q1, Q2, Q3, colorPalette } = props;

                // Création d'un dégradé en 4 couleurs pleines (gradient à paliers)
                const percentQ1 = ((Q1 - min) / (max - min)) * 100;
                const percentQ2 = ((Q2 - min) / (max - min)) * 100;
                const percentQ3 = ((Q3 - min) / (max - min)) * 100;

                const quartileGradient = `
                    linear-gradient(to bottom,
                        ${colorPalette[3]} 0%, ${colorPalette[3]} ${(100 - percentQ3)}%,
                        ${colorPalette[2]} ${(100 - percentQ3)}%, ${colorPalette[2]} ${(100 - percentQ2)}%,
                        ${colorPalette[1]} ${(100 - percentQ2)}%, ${colorPalette[1]} ${(100 - percentQ1)}%,
                        ${colorPalette[0]} ${(100 - percentQ1)}%, ${colorPalette[0]} 100%
                    )
                `;


                this._div.innerHTML = `
            <div class="legend-bar-container">
                <span class="legend-max">${max.toFixed(1)}</span>
                <div class="legend-bar" style="background: ${quartileGradient};">
                    <input type="range" id="seuilSlider" min="${min}" max="${max}" step="0.1" value="${currentValue}" orient="vertical">
                </div>
                <span class="legend-min">${min.toFixed(1)}</span>
            </div>
            <div class="valeur-seuil">
                <span id="valeurSlider">${currentValue}</span>
            </div>
        `;
            }

            // Slider : synchro curseur ↔ valeur affichée
            const slider = document.getElementById("seuilSlider");
            const output = document.getElementById("valeurSlider");
            const seuilInput = document.getElementById("seuilValue");

            if (slider && output) {
                L.DomEvent.disableClickPropagation(slider);
                L.DomEvent.disableScrollPropagation(slider);

                slider.addEventListener("input", () => {
                    output.textContent = slider.value;
                    if (seuilInput) seuilInput.value = slider.value;
                });

                if (seuilInput) {
                    seuilInput.addEventListener("input", () => {
                        const val = parseFloat(seuilInput.value);
                        if (!isNaN(val) && val >= props.min && val <= props.max) {
                            slider.value = val;
                            output.textContent = val;
                        }
                    });
                }
            }
        };

        legend.addTo(carte);

        // Fonction d'association d'un palette de couleur pour chaque indices
        function getColorPaletteForIndice(indice) {
            const palettes = {
                // Chaleur : vert - rouge
                "TXm_seas_JJA": ["#9bca68", "#d8433c"],
                "TMm_seas_JJA": ["#9bca68", "#d8433c"],
                "TX35D_yr": ["#9bca68", "#d8433c"],
                "TX30D_yr": ["#9bca68", "#d8433c"],

                // Pluie : bleu clair - bleu foncé
                "RRq99refD_yr": ["#e0f7fa", "#01579b"],
                "RRq99_yr": ["#e0f7fa", "#01579b"],
                "Rx1d_yr": ["#e0f7fa", "#01579b"],

                // Feu : jaune - rouge
                "IFM40_yr": ["#f3eb6d", "#ff0000"],
                "SWI04_yr": ["#f3eb6d", "#ff0000"],

                // Inondation : GRIS
                "ZonesInnondables": ["#413d46", "#413d46"],

                // Débit hydrologique : bleu ciel - violet CHANGER COULEURS
                "DebHyd": ["#FF0000", "#1350ED"]
            };

            return palettes[indice] || legend.update(); // par défaut on supprime la légende si l'indice n'est pas supporté (si c'est l'indice 'selectionner') 
        }

        // On associe un min et un max global pour chaque indice tout scénario confondu pour la cohérence visuelle
        function getMinMaxIndice(indice) {
            const bornes = {
                "TXm_seas_JJA": [5.62, 34.14],
                "TMm_seas_JJA": [3.85, 27.57],
                "TX35D_yr": [0, 40.7],
                "TX30D_yr": [0, 101.1],
                "Rx1d_yr": [25.61, 200.27],
                "RRq99_yr": [15.72, 112.57],
                "RRq99refD_yr": [2.2, 8.6],
                "IFM40_yr": [0, 82],
                "SWI04_yr": [0, 287],
                "DebHyd": [0, 1393] // Valeurs arbitraires , a verifier
            };
            return bornes[indice] || [0, 1]; // Valeurs par défaut si indice inconnu
        }
        function calculerQuartiles(valeurs) {
            const sorted = [...valeurs].sort((a, b) => a - b);
            const n = sorted.length;

            const quartile = (p) => {
                const index = (n - 1) * p;
                const lower = Math.floor(index);
                const upper = Math.ceil(index);
                const weight = index % 1;

                if (upper >= n) return sorted[lower];
                return sorted[lower] * (1 - weight) + sorted[upper] * weight;
            };

            return {
                Q1: quartile(0.25),
                Q2: quartile(0.5),
                Q3: quartile(0.95)
            };
        }

        // Cette fonction affiche l'explication liée à l'indice, la variable un_ou_deux est pour : 1-l'explication du premier indice, 2-du deuxième indice
        function afficherExplicationIndice(indice, un_ou_deux) {
            document.getElementById("explicationIndice").style.color = "#333"; // réinitialise la couleur du texte
            const explications = {
                "": "Veuilez sélectionner un scénario climatique",
                "ZonesInnondables": "Territoires à Risque d'Inondations, les TRI ne sont pas liés aux scénarios, source georisques.gouv",
                "TXm_seas_JJA": "Moyenne des températures maximales quotidiennes de la période été",
                "TMm_seas_JJA": "Moyenne des températures moyennes quotidiennes de la période été",
                "TX35D_yr": "Nombre de jours dans l'année où la température maximale dépasse 35°C.",
                "TX30D_yr": "Nombre de jours dans l'année où la température maximale dépasse 30°C.",
                "Rx1d_yr": "Intensité des précipitations extrêmes (max annuel des précipitations totales quotidiennes (mm)",
                "RRq99_yr": "Cumul de précipitations remarquables (percentile 99 du cumul  quotidien) (mm)",
                "RRq99refD_yr": "Nombre de jours où les précipitations quotidiennes dépassent le 99e centile des précipitations quotidiennes de l'année.",
                "IFM40_yr": "Nombre de jours où l'indicateur feux météo est supérieur à 40 (favorable à des départs de feu)",
                "SWI04_yr": "(Soil Wetness Index) Nombre de jours où SWI < 0.4, considéré comme sec",
                "DebHyd": "Moyenne sur 30ans des moyennes par saison des débit hydrologique des stations de mesure (m³/s)"
            };
            const texte = explications[indice] || "";
            if (un_ou_deux == 1) {
                document.getElementById("explicationIndice").textContent = texte;
            }
            else {
                document.getElementById("explicationIndice2").textContent = texte;
            }
        }

        // Fonction afficherScenario d'affichage d'un scénario donné
        function afficherScenario(fichierGeojson, annee, id_indice) {
            // Supprimer la couche précédente si elle existe
            if (scenarioLayerGroup) {
                carte.removeLayer(scenarioLayerGroup);
            }
            const indice2 = document.getElementById("datacrossSelect").value;
            if (indice2 != "") {
                croiserIndicesEtAfficher(fichierGeojson, id_indice, indice2);
                afficherExplicationIndice(indice2, 2);
            }
            else {
                const [couleur_min, couleur_max] = getColorPaletteForIndice(id_indice);
                fetch(fichierGeojson)
                    .then(response => response.json())
                    .then(data => {
                        // const features = data.features.filter(f => f.properties.Annee === annee);
                        const features = data.features.filter(f => f.properties[id_indice] !== undefined);
                        // Récupération des valeurs valides
                        const valeurs = features
                            .map(f => f.properties[id_indice])
                            .filter(val => val !== undefined && !isNaN(val));

                        // calcul du min et max
                        const minVal = Math.min(...valeurs);
                        const maxVal = Math.max(...valeurs);

                        // calcul des quartiles pour l'indice et le scénario sélectioné
                        const { Q1, Q2, Q3 } = calculerQuartiles(valeurs);

                        // affichage dans la console
                        console.log(`Indice : ${id_indice}`);
                        console.log(`→ Valeur min : ${minVal}`);
                        console.log(`→ Valeur max : ${maxVal}`);
                        console.log(`→ Q1 : ${Q1}`);
                        console.log(`→ Q2 : ${Q2}`);
                        console.log(`→ Q3 : ${Q3}`);

                        const [min2Val, max2Val] = getMinMaxIndice(id_indice);

                        const newLayer = L.layerGroup();

                        features.forEach(f => {
                            const lat = f.geometry.coordinates[1];
                            const lon = f.geometry.coordinates[0];
                            const val = f.properties[id_indice];
                            const squareCoords = getSquareAround(lat, lon, 8000); // 8km entre les stations météo
                            // on affiche pour chacune des valeurs la couleur du quartile associé,
                            let color;
                            const colorminQ1 = getColor(minVal, minVal, maxVal, couleur_min, couleur_max);
                            const colorQ1Q2 = getColor((maxVal - minVal) / 3, minVal, maxVal, couleur_min, couleur_max);
                            const colorQ2Q3 = getColor(2 * (maxVal - minVal) / 3, minVal, maxVal, couleur_min, couleur_max);
                            const colorQ3max = getColor(maxVal, minVal, maxVal, couleur_min, couleur_max);
                            paletteCouleurQuartiles = [colorminQ1, colorQ1Q2, colorQ2Q3, colorQ3max];

                            if (val <= Q1) color = colorminQ1; // couleur du minimum de la légende
                            else if (val <= Q2) color = colorQ1Q2;
                            else if (val <= Q3) color = colorQ2Q3;
                            else color = colorQ3max;// couleur du maximum de la légende

                            const poly = L.polygon(squareCoords, {
                                color: color,
                                fillColor: color,
                                fillOpacity: 0.60,
                                weight: 0,
                                pane: 'scenarioPane'
                            });
                            poly.addTo(newLayer);
                        });

                        // Mise à jour de la légende
                        legend.update({
                            id_indice: id_indice,
                            min: minVal,
                            max: maxVal,
                            colorMin: couleur_min,
                            colorMax: couleur_max
                        });
                        legend.update({
                            id_indice: id_indice,
                            min: minVal,
                            max: maxVal,
                            Q1, Q2, Q3,
                            colorPalette: paletteCouleurQuartiles
                        });


                        // On supprime la légende si l'indice est les TRI
                        if (id_indice == "ZonesInnondables") {
                            legend.update()
                        }

                        newLayer.addTo(carte);
                        scenarioLayerGroup = newLayer;
                    })
                    .catch(err => {
                        console.error("Erreur lors du chargement du fichier :", err);
                    });
            }

        }

        // Croisement des indices, pour l'instant, affiche en rouge les zones où les valeurs des deux indices sont supérieures à leur Q3
        function croiserIndicesEtAfficher(fichierGeojson, id_indice1, id_indice2) {
            // Supprimer la couche précédente si elle existe
            if (scenarioLayerGroup) {
                carte.removeLayer(scenarioLayerGroup);
            }

            fetch(fichierGeojson)
                .then(response => response.json())
                .then(data => {
                    const features = data.features.filter(f =>
                        f.properties[id_indice1] !== undefined &&
                        f.properties[id_indice2] !== undefined
                    );

                    const valeurs1 = features.map(f => f.properties[id_indice1]).filter(val => !isNaN(val));
                    const valeurs2 = features.map(f => f.properties[id_indice2]).filter(val => !isNaN(val));

                    const { Q3: Q3_1 } = calculerQuartiles(valeurs1);
                    const { Q3: Q3_2 } = calculerQuartiles(valeurs2);

                    console.log(`Croisement : ${id_indice1} & ${id_indice2}`);
                    console.log(`→ Q3 ${id_indice1} : ${Q3_1}`);
                    console.log(`→ Q3 ${id_indice2} : ${Q3_2}`);
                    const indice1Texte = indiceSelect.options[indiceSelect.selectedIndex].text;
                    const indice2Texte = datacrossSelect.options[datacrossSelect.selectedIndex].text;

                    console.log("Ici sont affiché en rouge les zones dans lesquelles les valeurs des indices croisés sont toutes deux présentes dans le dernier quartile des données, soit les zones où "+ indice1Texte + " est supérieur à "+ Q3_1 + " ET où " + indice2Texte + " est supérieur à "+ Q3_2);

                    const newLayer = L.layerGroup();

                    features.forEach(f => {
                        const val1 = f.properties[id_indice1];
                        const val2 = f.properties[id_indice2];

                        if (val1 > Q3_1 && val2 > Q3_2) {
                            const lat = f.geometry.coordinates[1];
                            const lon = f.geometry.coordinates[0];
                            const squareCoords = getSquareAround(lat, lon, 8000);

                            const poly = L.polygon(squareCoords, {
                                color: "#FF0000",
                                fillColor: "#FF0000",
                                fillOpacity: 0.7,
                                weight: 0,
                                pane: 'scenarioPane'
                            });
                            poly.addTo(newLayer);
                        }
                    });

                    newLayer.addTo(carte);
                    scenarioLayerGroup = newLayer;
                })
                .catch(err => {
                    console.error("Erreur dans croiserIndicesEtAfficher :", err);
                });
        }

        // Affiche les Territoires à risque d'inondation
        let inondLayer = null; // Couche des inondations

        function afficherInondation(fichier) {
            fetch(fichier)
                .then(res => res.json())
                .then(data => {
                    // Supprime l'ancienne couche si elle existe
                    if (inondLayer) {
                        carte.removeLayer(inondLayer);
                        inondLayer = null;
                    }
                    // Crée la nouvelle couche
                    inondLayer = L.geoJSON(data, {
                        pane: 'infraPane',
                        style: {
                            fillColor: "#c3b4d3",
                            color: "#5e5568",
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.6
                        }
                    }).addTo(carte);
                });
        }

        // fonction qui sert à afficher les débits hydrauliques 
        function afficherDebitHydro(fichierGeojson, saison, periode) {
            if (scenarioLayerGroup) {
                carte.removeLayer(scenarioLayerGroup);
            }

            fetch(fichierGeojson)
                .then(response => response.json())
                .then(data => {
                    const features = data.features.filter(f =>
                        f.properties.Periode === periode &&
                        f.properties[saison] !== undefined
                    );

                    // Calcul min/max dynamique
                    const valeurs = features.map(f => f.properties[saison]);
                    const minVal = Math.min(...valeurs);
                    const maxVal = Math.max(...valeurs);
                    // Affichage console
                    console.log(`Indice : ${"DebHyd"}`);
                    console.log(`→ Valeur min : ${minVal}`);
                    console.log(`→ Valeur max : ${maxVal}`);

                    const newLayer = L.layerGroup();

                    const [couleur_min, couleur_max] = getColorPaletteForIndice("DebHyd");

                    features.forEach(f => {
                        const val = f.properties[saison];
                        const color = getColor(val, minVal, maxVal, couleur_min, couleur_max);

                        const cercle = L.circleMarker([f.geometry.coordinates[1], f.geometry.coordinates[0]], {
                            radius: 6,
                            fillColor: color,
                            color: "#333",
                            weight: 1,
                            fillOpacity: 0.8,
                            pane: 'scenarioPane'
                        });

                        cercle.bindPopup(`<strong>${f.properties.nom_station}</strong><br>${saison} : ${val.toFixed(2)} m³/s`);
                        cercle.addTo(newLayer);
                    });

                    newLayer.addTo(carte);
                    scenarioLayerGroup = newLayer;

                    // Met à jour la légende
                    legend.update({
                        id_indice: "DebHyd",
                        min: minVal,
                        max: maxVal,
                        colorMin: couleur_min,
                        colorMax: couleur_max
                    });
                })
                .catch(err => console.error("Erreur affichage débit hydro :", err));
        }
        //Ajout du réseau ferré national Rfn
        let LignesRfnStyle = {
            "color": "#04354f",
            "weight": 1.2,
            "opacity": 0.95
        }
        let LignesRfn = L.geoJSON(lignesrfnJSON, {
            style: LignesRfnStyle,
            pane: 'reseauPane'
        }).addTo(carte)

        // Activer/Desactiver le réseau ferré national
        // Ciblage de la checkbox
        const lignesCheckbox = document.getElementById('checkboxLignes');
        // Activation/désactivation de la couche
        lignesCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                carte.addLayer(LignesRfn);
            } else {
                carte.removeLayer(LignesRfn);
            }
        });

        // Affiche les infrastructures 
        let infraLayer = null; // Couche des infrastructures

        // Fonction de style pour pour les lignes (ouvrages en terre) 
        function styleInfra(feature, estRisque = false) {
            if (feature.geometry.type === "LineString" || feature.geometry.type === "MultiLineString") {
                return {
                    color: "#A52A2A",
                    weight: estRisque ? 6 : 3,
                    opacity: 0.5
                };
            }
            return null;
        }

        // Fonction de style pour pour les points (autres infrastructures) 
        function pointToLayerInfra(feature, latlng, estRisque = false) {
            const value = document.getElementById("infraSelect").value;

            let color;
            if (value === "gares") color = "#0077b6"; // 
            else if (value === "ouvrages") color = "#f67d15";
            else if (value === "ponts_route") color = "#e43ea9";
            else if (value === "passerelles") color = "#9008a0";
            else color = "#0077b6";

            const rayon = estRisque ? 6 : 3;

            return L.circleMarker(latlng, {
                radius: rayon,
                fillColor: color,
                color: color,
                weight: 1,
                opacity: 1,
                fillOpacity: 0.7,
                pane: 'infraPane'
            });
        }

        function afficherInfrastructure(fichier) {
            if (fichier == null) return;
            fetch(fichier)
                .then(res => res.json())
                .then(data => {
                    if (infraLayer) {
                        carte.removeLayer(infraLayer);
                        infraLayer = null;
                    }

                    infraLayer = L.geoJSON(data, {
                        pane: 'infraPane',
                        style: function (feature) {
                            return styleInfra(feature, false);
                        },
                        pointToLayer: function (feature, latlng) {
                            return pointToLayerInfra(feature, latlng, false);
                        },
                        onEachFeature: function (feature, layer) {
                            if (feature.properties) {
                                const nom = feature.properties.nom || feature.properties.libelle || "Infrastructures";
                                layer.bindPopup(`<strong>${nom}</strong>`);
                            }
                        }
                    }).addTo(carte);
                });
        }

        // Cette fonction zoneARisque stocke les points à risque concernant un indice, d'une année, d'un fichier geojson, au dessus d'un seuil précisé
        async function zoneARisque(fichierGeojson, annee, indice, seuil) {
            try {
                const response = await fetch(fichierGeojson);
                const data = await response.json();

                // Filtrer les points correspondant à l'année et au seuil
                const featuresFiltrees = data.features.filter(feature =>
                    feature.properties &&
                    feature.properties[indice] !== undefined &&
                    feature.properties[indice] >= seuil
                );

                return featuresFiltrees;

            } catch (error) {
                console.error(`Erreur lors du chargement ou du filtrage de ${fichierGeojson} :`, error);
                return [];
            }
        }

        // Cette fonction charge les infrastructures et affiche uniquement celles présentes dans un rayon de 4km d'une zone à risque définie par un indice et un seuil
        // Traite les zones innondables à part, en vérifiant l'intersection avec les zones
        async function chargerInfraARisque(geojsonInfra, fichierScenar, annee, indice, seuil) {
            const rayon = 4000;

            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371000; // rayon de la terre en mètres
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) ** 2 +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon / 2) ** 2;
                return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            }

            try {
                let zones = [];

                if (indice !== "ZonesInnondables") {
                    zones = await zoneARisque(fichierScenar, annee, indice, seuil);
                } else {
                    const response = await fetch("data-METEO/n_tri_s.geojson");
                    const data = await response.json();
                    zones = data.features;
                }

                // Prépare les bbox des zones (optimisation de temps de calcul pour les TRI)
                const zonesAvecBbox = zones.map(zone => ({
                    feature: zone,
                    bbox: turf.bbox(zone) // [minX, minY, maxX, maxY]
                }));

                const res = await fetch(geojsonInfra);
                const dataInfra = await res.json();

                let infraARisque = [];

                if (indice === "ZonesInnondables") {
                    console.time("filtrage TRI"); // timer pour savoir le temps de calcul des infra dans les tri

                    infraARisque = dataInfra.features.filter(feature => {
                        if (!feature.geometry) return false;

                        const type = feature.geometry.type;
                        // Pour les TRI, on ne teste la présence dans une zone TRI que si elle fait partie d'une bbox englobante
                        if (type === "Point") {
                            const [lon, lat] = feature.geometry.coordinates;

                            const candidats = zonesAvecBbox.filter(z => {
                                const [minX, minY, maxX, maxY] = z.bbox;
                                return lon >= minX && lon <= maxX && lat >= minY && lat <= maxY;
                            });

                            return candidats.some(z => turf.booleanPointInPolygon(feature, z.feature));
                        }
                        if (type === "LineString" || type === "MultiLineString") {
                            const bboxFeature = turf.bbox(feature);
                            const bboxPolygon = turf.bboxPolygon(bboxFeature);

                            const candidats = zonesAvecBbox.filter(z => {
                                const [minX, minY, maxX, maxY] = z.bbox;
                                return !(bboxFeature[2] < minX || bboxFeature[0] > maxX ||  // disjoint sur X
                                    bboxFeature[3] < minY || bboxFeature[1] > maxY);   // disjoint sur Y
                            });

                            return candidats.some(z => turf.booleanIntersects(feature, z.feature));
                        }
                        return false;
                    });

                    console.timeEnd("filtrage TRI");
                }
                else {
                    // Méthode classique pour les autres indices
                    infraARisque = dataInfra.features.filter(feature => {
                        const pt = feature.properties.geo_point_2d;
                        return zones.some(z => {
                            const [zLon, zLat] = z.geometry.coordinates;
                            return haversineDistance(pt.lat, pt.lon, zLat, zLon) < rayon;
                        });
                    });
                }

                const couche = {
                    ...dataInfra,
                    features: infraARisque
                };

                if (infraLayer) {
                    carte.removeLayer(infraLayer);
                    infraLayer = null;
                }

                infraLayer = L.geoJSON(couche, {
                    pane: 'infraPane',
                    style: feature => styleInfra(feature, true),
                    pointToLayer: (feature, latlng) => pointToLayerInfra(feature, latlng, true),
                    onEachFeature: (feature, layer) => {
                        if (feature.properties) {
                            const nom = feature.properties.libelle || 'Non nommé, id réseau :' + feature.properties.idreseau;
                            layer.bindPopup(`<strong>${nom}</strong>`);

                        }
                    }
                }).addTo(carte);
                // On remplace les libelle null par l'idreseau qui je suppose est unique, pour éviter d'oublier les infrastructures qui ont un libelle : null 
                const libellesUniques = new Set(
                    infraARisque.map(f => f.properties.libelle !== null
                        ? f.properties.libelle
                        : `Non nommé, id réseau :${f.properties.idreseau}`)
                );
                const select = document.getElementById("infraSelect");
                const infra_nom = select.options[select.selectedIndex].text;
                const indiceSelect = document.getElementById("indiceSelect");
                const indiceTexte = indiceSelect.options[indiceSelect.selectedIndex].text;
                const seuil1 = parseFloat(document.getElementById("seuilValue").value);

                if (indiceSelect.value != "ZonesInnondables") {
                    document.getElementById("nombreOuvrages").textContent =
                        libellesUniques.size + ' ' + infra_nom + ' dont l’indice ' + indiceTexte + ' est supérieur à ' + seuil1 + ' :';
                }
                else {
                    document.getElementById("nombreOuvrages").textContent =
                        libellesUniques.size + ' ' + infra_nom + ' en ' + indiceTexte;
                }

                console.log(infraARisque);
                const listeElem = document.getElementById("listeOuvrages");
                listeElem.innerHTML = "";

                libellesUniques.forEach(lib => {
                    const li = document.createElement("li");
                    li.textContent = lib;
                    listeElem.appendChild(li);
                });

            } catch (err) {
                console.error("Erreur dans chargerInfraARisque :", err);
            }
        }

        // Récupère l'infrastructure selectionnée, renvoie le fichier
        function getSelectedInfraInfo() {
            const value = document.getElementById("infraSelect").value;
            switch (value) {
                case 'gares':
                    return { fichier: 'data-SNCF/liste-des-gares.geojson' };
                case 'ouvrages':
                    return { fichier: 'data-SNCF/liste-ouvrages-en-terre.geojson' };
                case 'ponts_route':
                    return { fichier: 'data-SNCF/liste-des-ponts-route.geojson' };
                case 'passerelles':
                    return { fichier: 'data-SNCF/liste-des-passerelles.geojson' };
                default:
                    return null;
            }
        }

        // Récupère le scénario selectionné, renvoie le fichier et l'année d'intérêt
        function getSelectedScenarioInfo() {
            const scenario = document.querySelector('input[name="scenario"]:checked');
            if (!scenario) return "";

            const value = scenario.value;
            switch (value) {
                case 'actuel':
                    return { fichier: 'data-METEO/indicesDRIAS2023moyenne.geojson', annee: 2005 };
                case '2030':
                    return { fichier: 'data-METEO/indicesDRIAS2030moyenne.geojson', annee: 2037 };
                case '2050':
                    return { fichier: 'data-METEO/indicesDRIAS2050moyenne.geojson', annee: 2053 };
                case '2100':
                    return { fichier: 'data-METEO/indicesDRIAS2100moyenne.geojson', annee: 2098 };
                default:
                    return null;
            }
        }

        // Affiche l'indice en fonction du scénario selectionné
        document.querySelectorAll('input[name="scenario"]').forEach(radio => {
            radio.addEventListener('change', function () {
                document.getElementById("explicationIndice").textContent = "";
                document.getElementById("nombreOuvrages").textContent = '';
                document.getElementById("listeOuvrages").innerHTML = "";
                const scenario_info = getSelectedScenarioInfo();
                const selectedIndice = document.getElementById("indiceSelect").value;
                const infra_info = getSelectedInfraInfo(); // Récupère LE FICHIER infrastructure
                const infra = document.getElementById("infraSelect").value;
                const indice = document.getElementById("indiceSelect").value; // Recupère l'indice
                afficherExplicationIndice(indice, 1); // Affiche l’explication
                const seuil = parseFloat(document.getElementById("seuilValue").value);
                if (scenario_info && selectedIndice != "") {
                    if (selectedIndice == "DebHyd") {
                        const scenario = document.querySelector('input[name="scenario"]:checked');
                        const periode = scenario.value;
                        const saison = document.getElementById("saisonSelect").value;
                        if (saison == "") {
                            document.getElementById("explicationIndice").textContent = "Veuillez sélectionner une saison pour afficher les débits hydrologiques";
                            document.getElementById("explicationIndice").style.color = "red";
                            return;
                        }
                        else {
                            afficherDebitHydro("data-EAU/station-debit-saison-scenario.geojson", saison, periode);
                            console.log("Débit hydro affichés : " + saison + " - " + periode);
                            afficherExplicationIndice("DebHyd", 1);
                        }

                    }
                    else {
                        afficherScenario(scenario_info.fichier, scenario_info.annee, selectedIndice);
                    }
                    if (selectedIndice && infra && seuil != 0) {
                        chargerInfraARisque(infra_info.fichier, scenario_info.fichier, scenario_info.annee, indice, seuil);
                    }
                }
                if (selectedIndice == "") { // si aucun indice n'est sélectionné
                    console.log("Aucun indice sélectionné");
                    // mettre en rouge le texte de l'indice
                    document.getElementById("explicationIndice").textContent = "Veuillez sélectionner un indice";
                    document.getElementById("explicationIndice").style.color = "red";
                }
            });
        });

        // Affiche le scénario en fonction de l'indice sélectionné, (affiche le détail/explication de l'indice)
        document.getElementById("indiceSelect").addEventListener("change", () => {
            // Réaffiche les infos du seuil 
            seuilContainer.style.display = "block";
            labelseuil.style.display = "block";
            explication_seuil.style.display = "block";

            const indice = document.getElementById("indiceSelect").value;
            saisonContainer.style.display = "none"; // supprime la sélection des saisons
            probabiliteContainer.style.display = "none"; // supprime la sélection des probabilité d'inondation
            document.getElementById("datacrossSelect").selectedIndex = 0; // remet à 0 la sélection du croisement des données
            document.getElementById("explicationIndice2").innerHTML = ""; // supprime l'explication du 2 eme indice
            croiseavec.style.display = "none"; // supprime le "croisé avec"

            afficherExplicationIndice(indice, 1); // Affiche l’explication
            if (indice == "ZonesInnondables") {
                probabiliteContainer.style.display = "block"; // Affiche le sélecteur de probabilité des zones inondables
                // Demnde la sélection de la probabilité
                document.getElementById("explicationIndice").textContent = "Veuillez sélectionner une probabilité pour afficher les zones inondables";
                document.getElementById("explicationIndice").style.color = "red";
                // Suprrime les info de seuil 
                seuilContainer.style.display = "none";
                labelseuil.style.display = "none";
                explication_seuil.style.display = "none";

                legend.update();
                document.querySelectorAll('#SelectionScenarios input[type="radio"]').forEach(cb => cb.checked = false);
                if (scenarioLayerGroup) carte.removeLayer(scenarioLayerGroup);
                afficherInondation("data-METEO/n_tri_s.geojson")
                document.getElementById("explication_seuil").textContent = "Les territoires à risque d'inondation ne nécessitent pas de seuil, sélectionnez une infrastructure puis cliquez Afficher pour voir les infrastructures à risque";
                const infra_info = getSelectedInfraInfo(); // Récupère infrastructure
                const scenario_info = getSelectedScenarioInfo();
                chargerInfraARisque(infra_info.fichier, scenario_info.fichier, scenario_info.annee, indice, 0)

            }
            if (indice == "DebHyd") {
                saisonContainer.style.display = "block"; // Affiche le sélecteur
                // Demnde la sélection de la saison
                document.getElementById("explicationIndice").textContent = "Veuillez sélectionner une saison pour afficher les débits hydrologiques";
                document.getElementById("explicationIndice").style.color = "red";
                // Suprrime les info de seuil 
                seuilContainer.style.display = "none";
                labelseuil.style.display = "none";
                explication_seuil.style.display = "none";

                document.getElementById("saisonSelect").selectedIndex = 0;

                legend.update();
                if (scenarioLayerGroup) carte.removeLayer(scenarioLayerGroup);
                const scenario = document.querySelector('input[name="scenario"]:checked');
                if (!scenario) return "";
                const periode = scenario.value;
                const saison = document.getElementById("saisonSelect").value;
                if (saison == "") {
                    document.getElementById("explicationIndice").textContent = "Veuillez sélectionner une saison pour afficher les débits hydrologiques";
                    document.getElementById("explicationIndice").style.color = "red";
                    return;
                }
                else {
                    afficherDebitHydro("data-EAU/station-debit-saison-scenario.geojson", saison, periode);
                    console.log("Débit hydro affichés : " + saison + " - " + periode);
                    afficherExplicationIndice("DebHyd", 1);
                }

                // const scenario_info = getSelectedScenarioInfo(); ne sert à rien ?
            } else {
                document.getElementById("explication_seuil").textContent = "Indiquez une valeur de seuil concernant l'indice sélectionné pour afficher les infrastructures que vous définissez à risque";
                const info = getSelectedScenarioInfo();
                if (inondLayer) carte.removeLayer(inondLayer);
                if (!info) {
                    // console.log("Aucun scénario sélectionné");
                    if (indice != "") {
                        console.log(indice);
                        document.getElementById("explicationIndice").textContent = "Veuillez sélectionner un scénario climatique";
                        document.getElementById("explicationIndice").style.color = "red";
                    }
                    else {
                        document.getElementById("explicationIndice").textContent = "Veuillez sélectionner un indice";
                        document.getElementById("explicationIndice").style.color = "red";
                    }
                };
                if (indice == "") {
                    document.getElementById("explicationIndice").textContent = "Veuillez sélectionner un indice";
                    document.getElementById("explicationIndice").style.color = "red";
                }

                afficherScenario(info.fichier, info.annee, indice);
                document.getElementById("nombreOuvrages").textContent = '';
                document.getElementById("listeOuvrages").innerHTML = "";
                // remet à zéro le seuil
                document.getElementById("seuilValue").value = 0;
                // remove le pane des infra a risques
                if (infraLayer) {
                    carte.removeLayer(infraLayer);
                    infraLayer = null;
                }
            }
        });

        // au changement de sélection du sélecteur de croisement de données, affiche les données croisées
        document.getElementById("datacrossSelect").addEventListener("change", () => {
            // Suprrime les info de seuil 
            seuilContainer.style.display = "none";
            labelseuil.style.display = "none";
            explication_seuil.style.display = "none";
            // Ajout du "croisé avec" et de l'explication de l'indice
            croiseavec.style.display = "block";

            const indice2 = document.getElementById("datacrossSelect").value;
            afficherExplicationIndice(indice2, 2);
            const scenario_info = getSelectedScenarioInfo();
            const indice1 = document.getElementById("indiceSelect").value;

            if (indice2 != "") {
                croiserIndicesEtAfficher(scenario_info.fichier, indice1, indice2);
                afficherExplicationIndice(indice2, 2);

            }
            else {
                // Réaffiche les info de seuil 
                seuilContainer.style.display = "block";
                labelseuil.style.display = "block";
                explication_seuil.style.display = "block";
                afficherScenario(scenario_info.fichier, scenario_info.annee, indice1)
                croiseavec.style.display = "none"; // enlever le "croisé avec"
                document.getElementById("explicationIndice2").innerHTML = "";

            }
        });

        // affiche au changement de sélection des saisons les débits hydrologiques
        document.getElementById("saisonSelect").addEventListener("change", () => {
            const scenario = document.querySelector('input[name="scenario"]:checked');
            const saison = document.getElementById("saisonSelect").value;
            if (saison == "") {
                document.getElementById("explicationIndice").textContent = "Veuillez sélectionner une saison pour afficher les débits hydrologiques";
                document.getElementById("explicationIndice").style.color = "red";
                return;
            }
            else {
                if (scenario == null) {
                    document.getElementById("explicationIndice").textContent = "Veuillez sélectionner un scénario climatique";
                    document.getElementById("explicationIndice").style.color = "red";
                    return;
                }
                else {
                    afficherExplicationIndice("DebHyd", 1);
                    const periode = scenario.value;
                    afficherDebitHydro("data-EAU/station-debit-saison-scenario.geojson", saison, periode);
                    console.log("Débit hydro affichés : " + saison + " - " + periode);
                    afficherExplicationIndice("DebHyd", 1);
                }
            }
        });

        // Affiche les infrastructures sélectionnées depuis la rubrique Réseau
        document.getElementById("infraSelect").addEventListener("click", () => {
            const infra = document.getElementById("infraSelect").value;
            const info = getSelectedInfraInfo();
            if (infra == "") { // A la non selection d'indice (click sur "Séléctionner")
                document.getElementById("nombreOuvrages").textContent = "";
                document.getElementById("listeOuvrages").innerHTML = "";
                console.log(infraLayer);

                // Supprime l'ancienne couche si elle existe            
                if (infraLayer) {
                    console.log("Supprimer l'ancienne couche infraLayer");
                    carte.removeLayer(infraLayer);
                    infraLayer = null;
                }
            }

            // Affiche les infrastructures à risque si le seuil n'est pas à 0 et qu'un indice est sélectionné
            const selectedIndice = document.getElementById("indiceSelect").value;
            const seuil = parseFloat(document.getElementById("seuilValue").value);
            if (selectedIndice && infra != "" && seuil != 0) {
                const scenario_info = getSelectedScenarioInfo();
                const indice = document.getElementById("indiceSelect").value; // Recupère l'indice
                chargerInfraARisque(info.fichier, scenario_info.fichier, scenario_info.annee, indice, seuil);
                document.getElementById("OuvragesArisqueDetecte").textContent = "";
            }
            else {
                afficherInfrastructure(info.fichier)
                document.getElementById("nombreOuvrages").textContent = '';
                document.getElementById("listeOuvrages").innerHTML = "";
            }
        });

        // Gère le bouton "Afficher" de l'affichage des ouvrages seuillés
        document.getElementById("afficherBtn").addEventListener("click", async () => {
            const scenario_info = getSelectedScenarioInfo(); // Récupère scénario + année
            const infra_info = getSelectedInfraInfo(); // Récupère infrastructure
            const select = document.getElementById("infraSelect");
            const infra_nom = select.options[select.selectedIndex].text;// récupère le contenu et non la value 
            const indice = document.getElementById("indiceSelect").value; // Recupère l'indice
            const seuil = parseFloat(document.getElementById("seuilValue").value);
            document.getElementById("OuvragesArisqueDetecte").textContent = "";

            if (infraSelect.value == "") {
                document.getElementById("OuvragesArisqueDetecte").style.color = "red";
                document.getElementById("OuvragesArisqueDetecte").textContent = "Veuillez sélectionner un une infrastructure";
                return;
            }
            // Supprime l'ancienne couche si elle existe
            if (infraLayer) {
                carte.removeLayer(infraLayer);
                infraLayer = null;
            }
            // Si on veut afficher les tri sans avoir sélectionné de scénario, corrige l'erreur cannot read properties of null pour le fichier scenario
            if (indice == "ZonesInnondables" && !scenario_info) {
                // scenario_info = { fichier: "data-METEO/indicesDRIAS2050moyenne.geojson", annee: 0 }; // On met une année fictive
            }
            // Appelle ta fonction de filtrage/affichage
            await chargerInfraARisque(infra_info.fichier, scenario_info.fichier, scenario_info.annee, indice, seuil);
        });

        // Gère le bouton nettoyer carte
        function nettoyerCarte() {
            carte.eachLayer(function (layer) {
                // Ne  supprime pas le fond de carte
                if (layer instanceof L.TileLayer) return;
                // Supprime toute autre couche
                carte.removeLayer(layer);
            });

            // Réinitialise l'affichage
            legend.update();
            document.getElementById("nombreOuvrages").textContent = '';
            document.getElementById("listeOuvrages").innerHTML = "";
            document.getElementById("explicationIndice").innerHTML = "";
            document.getElementById("explicationIndice2").innerHTML = "";
            croiseavec.style.display = "none";
            document.querySelectorAll('#SelectionReseau input[type="checkbox"]').forEach(cb => cb.checked = false);
            document.querySelectorAll('#SelectionScenarios input[type="radio"]').forEach(cb => cb.checked = false);
            document.getElementById("infraSelect").selectedIndex = 0;
            document.getElementById("indiceSelect").selectedIndex = 0;
            document.getElementById("saisonSelect").selectedIndex = 0;
            document.getElementById("datacrossSelect").selectedIndex = 0;


            //Supprime la sélection de saison
            saisonContainer.style.display = "none"; // Affiche le sélecteur
            // Réaffiche les infos du seuil si supprimés
            seuilContainer.style.display = "block";
            labelseuil.style.display = "block";
            explication_seuil.style.display = "block";
        }

        // Gère le bouton de nettoyage de la carte
        document.getElementById("clearcarte").addEventListener("click", nettoyerCarte);

        // Gère le bouton de la fenetre d'intro
        document.getElementById("closeModalBtn").addEventListener("click", () => {
            document.getElementById("modalIntro").style.display = "none";
        });

        // Gère le bouton d'information sur le header
        document.getElementById("infoBtn").addEventListener("click", () => {
            document.getElementById("modalIntro").style.display = "flex";
        });

    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="fr">