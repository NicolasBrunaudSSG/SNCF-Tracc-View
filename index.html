<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cartographie TRACC</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <link rel="stylesheet" href="style.css">

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="data-SNCF/lignesrfn.geojson.js"></script>
</head>

<body>
    <header>
        <h1>SNCF TRACC View
            <span id="infoBtn" title="Informations">
                ℹ️
            </span>
        </h1>
    </header>

    <!-- Rubrique réseau à gauche -->
    <aside id="SelectionReseau">
        <h2>Réseau</h2>
        <!-- Checkbox du réseau national -->
        <form>
            <label><input type="checkbox" id="checkboxLignes" checked> Lignes du réseau national</label><br>
            <!-- Sélection de l'infrastructure à afficher -->
            <label for="infraSelect" style="margin-bottom: -5px;"><strong>Infrastructures à afficher
                    :</strong></label><br>
            <select id="infraSelect" style="width: 100%; margin-top: 5px;">
                <option value="" name="infra"> Sélectionner </option>
                <option value="gares" name="infra">Gares</option>
                <option value="ouvrages" name="infra">Ouvrages en terre</option>
                <option value="ponts_route" name="infra">Ponts-route</option>
                <option value="passerelles" name="infra">Passerelles</option>
            </select>
        </form>
        <!-- Résultat des infrastructures à risque-->
        <div id="resultatsOuvrages" style="margin-top: 15px; align-items: center;">
            <div id="OuvragesArisqueDetecte" style="font-weight:bold">Infrastructures à risque :</div>
            <div id="nombreOuvrages" style="font-weight:bold"></div>
            <div id="nomsOuvrages">
                <ul id="listeOuvrages"></ul>
            </div>
        </div>
    </aside>

    <!-- Carte au centre -->
    <div id="map"></div>

    <!-- Rubrique scénarios à droite -->
    <!-- Sélection des scénarios -->
    <aside id="SelectionScenarios">
        <button id="clearcarte" style="width:230px; margin-bottom: 20px;">Nettoyer la carte</button>
        <h2>Scénarios climatiques</h2>
        <form>
            <label class="scenario-label">
                <input type="radio" name="scenario" value="actuel"> Référence
                <div class="scenario-explication">Période de référence : 1976–2005</div>
            </label>

            <label class="scenario-label">
                <input type="radio" name="scenario" value="2030"> Horizon 2030
                <div class="scenario-explication">Monde ➞ +1.5°C / <strong>France ➞ +2°C</strong></div>
            </label>

            <label class="scenario-label">
                <input type="radio" name="scenario" value="2050"> Horizon 2050
                <div class="scenario-explication">Monde ➞ +2°C / <strong>France ➞ +2,7°C</strong></div>
            </label>

            <label class="scenario-label">
                <input type="radio" name="scenario" value="2100"> Horizon 2100
                <div class="scenario-explication">Monde ➞ +3°C / <strong>France ➞ +4°C</strong></div>
            </label>

        </form>

        <!-- Sélection des indices -->
        <h3>Indice à afficher</h3>
        <select id="indiceSelect">
            <option value=""> Sélectionner </option>
            <option value="ZonesInnondables">Zones innondables</option>
            <option value="TXm_seas_JJA">Température maximale en été (°C)</option>
            <option value="TMm_seas_JJA">Température moyenne en été (°C)</option>
            <option value="TX35D_yr">Jours ≥ 35°C</option>
            <option value="TX30D_yr">Jours ≥ 30°C</option>
            <option value="Rx1d_yr">Max pluie extrême (mm)</option>
            <option value="RRq99_yr">Pluies extrêmes (mm)</option>
            <option value="RRq99refD_yr">Fréquence pluie remarquable (j)</option>
            <option value="IFM40_yr">Feux météo (j)</option>

            <!-- Texte explicatif des indices-->
        </select>
        <div id="explicationIndice" class="texte-explicatif"
            style="margin-top: 10px; font-size: 0.9em; font-style: italic; color: #333;">
        </div>
        <!-- Texte explicatif du seuil-->
        <h3 id="labelseuil">Seuil de risque </h3><span id="explication-seuil" class="texte-explicatif"
            style="margin-top: 0px; font-size: 0.9em; font-style: italic; color: #333;">Indiquez une valeur de seuil
            concernant l'indice sélectionné pour afficher les infrastructures que vous définissez à risque</span>
        <div id="seuilContainer">
            <input type="number" id="seuilValue" value="0" style="width: 60px; margin-left: 20px;">
            <button id="afficherBtn" style="margin-left: 30px;">Afficher</button>

    </aside>

    <div id="modalIntro" class="modal">
        <div class="modal-content">
            <h2>Bienvenue sur SNCF TRACC View</h2>
            <p>
                SNCF TRACC View est un outil pédagogique et décisionnel permettant de visualiser et d'anticiper les
                impacts du changement climatique sur les infrastructures ferroviaires. <br>
                <br><em>(TRACC : trajectoire de réchauffement de référence pour l'adaptation au changement
                    climatique)</em>
            </p>
            <p>
                Cette application interactive vous permet :
            <ul>
                <li>D'explorer les risques climatiques selon différents <strong>scénarios TRACC</strong>.</li>
                <li>De visualiser plusieurs <strong>indices d'aléas climatiques</strong>.</li>
                <li>De cibler différents <strong>types d'infrastructures</strong>.</li>
                <li>De définir un <strong>seuil de risque personnalisé</strong>.</li>
            </ul>
            </p>
            <p><em>Sources : DRIAS-climat, DRIAS-eau, SNCF Open Data, GeoRisque.gouv</em></p>
            <button id="closeModalBtn">Accéder à l'application</button>
        </div>
    </div>

    <script>
        //Centrer la carte sur la France
        const carte = L.map('map').setView([47.07, 2.02], 5.5);
        //Ajouter le fond de carte d'OpenStreetMap
        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {
            foo: 'bar',
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(carte);

        // Création d'un Pane et attribution d'une priorité dans la visualisation (Z=650, 450 par défaut) utilisé pour le rfn
        carte.createPane('reseauPane');
        carte.getPane('reseauPane').style.zIndex = 650;

        // Création d'un Pane et attribution d'une priorité dans la visualisation (Z=650, 450 par défaut) utilisé pour les infrastructures à risque
        carte.createPane('infraPane');
        carte.getPane('infraPane').style.zIndex = 800;

        // Ajout du pane pour les scénarios
        carte.createPane('scenarioPane');
        carte.getPane('scenarioPane').style.zIndex = 400;

        // On met le pane des popups au dessus des autres pour qu'il soient visibles 
        carte.getPane('popupPane').style.zIndex = 1000;

        // Fonction qui permet de renvoyer une couleur sur une palette allant de couleur min à couleur max, associées à une valeur min et valeur max
        function getColor(val, min, max, colorMin, colorMax) {
            // Convertir les couleurs hexadécimales en RGB
            function hexToRgb(hex) {
                hex = hex.replace('#', '');
                if (hex.length === 3) {
                    hex = hex.split('').map(c => c + c).join('');
                }
                const bigint = parseInt(hex, 16);
                return {
                    r: (bigint >> 16) & 255,
                    g: (bigint >> 8) & 255,
                    b: bigint & 255
                };
            }

            // Convertir RGB en couleur hexadécimale
            function rgbToHex(r, g, b) {
                return "#" + [r, g, b].map(x => {
                    const hex = Math.round(x).toString(16);
                    return hex.length === 1 ? "0" + hex : hex;
                }).join('');
            }

            // Insérer val dans [min, max]
            const ratio = Math.max(0, Math.min(1, (val - min) / (max - min)));
            const c1 = hexToRgb(colorMin);
            const c2 = hexToRgb(colorMax);
            const r = c1.r + (c2.r - c1.r) * ratio;
            const g = c1.g + (c2.g - c1.g) * ratio;
            const b = c1.b + (c2.b - c1.b) * ratio;
            return rgbToHex(r, g, b);
        }

        // La position en degré des valeurs ne permet pas un rendu propre sans conversion en mètres
        // Fonction pour approx. la distance en degrés correspondant à un côté de N mètres
        function metersToDegreesLat(meters) {
            return meters / 111320; // 1° lat ~ 111.32 km
        }

        function metersToDegreesLon(meters, latitude) {
            return meters / (40075000 * Math.cos(latitude * Math.PI / 180) / 360); // dépend de la latitude
        }

        // Fonction pour créer un carré en mètres 
        function getSquareAround(lat, lon, meters = 5000) {
            const dLat = metersToDegreesLat(meters) / 2;
            const dLon = metersToDegreesLon(meters, lat) / 2;
            return [
                [lat - dLat, lon - dLon],
                [lat - dLat, lon + dLon],
                [lat + dLat, lon + dLon],
                [lat + dLat, lon - dLon],
                [lat - dLat, lon - dLon]
            ];
        }

        let scenarioLayerGroup = null; // Pour stocker la couche affichée
        // Ajout d'une légende à la carte
        const legend = L.control({ position: 'bottomright' });

        legend.onAdd = function (map) {
            this._div = L.DomUtil.create('div', 'custom-legend');
            this.update();
            return this._div;
        };

        legend.update = function (props) {
            if (!props) {
                this._div.innerHTML = '';
                return;
            }

            const { id_indice, min, max, colorMin, colorMax } = props;

            // Sauvegarder la valeur actuelle si slider déjà présent
            const existingSlider = document.getElementById("seuilSlider");
            let currentValue = min;
            if (existingSlider) {
                currentValue = existingSlider.value;
                // Optionnel : vérifie que la valeur est toujours dans la plage min/max
                if (currentValue < min) currentValue = min;
                if (currentValue > max) currentValue = max;
            }

            this._div.innerHTML = `
        <div class="legend-bar-container">
            <span class="legend-max">${max.toFixed(1)}</span>
            <div class="legend-bar">
                <input type="range" id="seuilSlider" min="${min}" max="${max}" step="0.1" value="${currentValue}" orient="vertical">
            </div>
            <span class="legend-min">${min.toFixed(1)}</span>
        </div>
        <div class="valeur-seuil">
            <span id="valeurSlider">${currentValue}</span>
        </div>
    `;

            // Appliquer les couleurs au dégradé
            const legendBar = this._div.querySelector(".legend-bar");
            legendBar.style.background = `linear-gradient(to bottom, ${colorMax}, ${colorMin})`;


            // Synchronisation slider ↔ input
            const slider = document.getElementById("seuilSlider");

            // Empêche la carte de bouger quand on clique ou glisse sur le slider
            L.DomEvent.disableClickPropagation(slider);
            L.DomEvent.disableScrollPropagation(slider);

            const output = document.getElementById("valeurSlider");
            const seuilInput = document.getElementById("seuilValue");

            slider.addEventListener("input", () => {
                output.textContent = slider.value;
                seuilInput.value = slider.value;
            });

            seuilInput.addEventListener("input", () => {
                const val = parseFloat(seuilInput.value);
                if (!isNaN(val) && val >= min && val <= max) {
                    slider.value = val;
                    output.textContent = val;
                }
            });
        };

        legend.addTo(carte);

        // Fonction d'association d'un palette de couleur pour chaque indices
        function getColorPaletteForIndice(indice) {
            const palettes = {
                // Chaleur : vert - rouge
                "TXm_seas_JJA": ["#9bca68", "#d8433c"],
                "TMm_seas_JJA": ["#9bca68", "#d8433c"],
                "TX35D_yr": ["#9bca68", "#d8433c"],
                "TX30D_yr": ["#9bca68", "#d8433c"],

                // Pluie : bleu clair - bleu foncé
                "RRq99refD_yr": ["#e0f7fa", "#01579b"],
                "RRq99_yr": ["#e0f7fa", "#01579b"],
                "Rx1d_yr": ["#e0f7fa", "#01579b"],

                // Feu : jaune - rouge
                "IFM40_yr": ["#f3eb6d", "#ff0000"],

                // Inondation : GRIS
                "ZonesInnondables": ["#413d46", "#413d46"]
            };

            return palettes[indice] || legend.update(); // par défaut on supprime la légende si l'indice n'est pas supporté (si c'est l'indice 'selectionner') 
        }

        // On associe un min et un max global pour chaque indice tout scénario confondu pour la cohérence visuelle
        function getMinMaxIndice(indice) {
            const bornes = {
                "TXm_seas_JJA": [5.62, 34.14],
                "TMm_seas_JJA": [3.85, 27.57],
                "TX35D_yr": [0, 40.7],
                "TX30D_yr": [0, 101.1],
                "Rx1d_yr": [25.61, 200.27],
                "RRq99_yr": [15.72, 112.57],
                "RRq99refD_yr": [2.2, 8.6],
                "IFM40_yr": [0, 82],
            };

            return bornes[indice] || [0, 1]; // Valeurs par défaut si indice inconnu
        }

        // Cette fonction affiche l'explication liée à l'indice 
        function afficherExplicationIndice(indice) {
            document.getElementById("explicationIndice").style.color = "#333"; // réinitialise la couleur du texte
            const explications = {
                "": "Veuilez sélectionner un scénario climatique",
                "ZonesInnondables": "Territoires à Risque d'Inondations, les TRI ne sont pas liés aux scénarios, source georisques.gouv",
                "TXm_seas_JJA": "Moyenne des températures maximales quotidiennes de la période été",
                "TMm_seas_JJA": "Moyenne des températures moyennes quotidiennes de la période été",
                "TX35D_yr": "Nombre de jours dans l'année où la température maximale dépasse 35°C.",
                "TX30D_yr": "Nombre de jours dans l'année où la température maximale dépasse 30°C.",
                "Rx1d_yr": "Intensité des précipitations extrêmes (max annuel des précipitations totales quotidiennes (mm)",
                "RRq99_yr": "Cumul de précipitations remarquables (percentile 99 du cumul  quotidien) (mm)",
                "RRq99refD_yr": "Nombre de jours où les précipitations quotidiennes dépassent le 99e centile des précipitations quotidiennes de l'année.",
                "IFM40_yr": "Nombre de jours où l'indicateur feux météo est supérieur à 40 (favorable à des départs de feu)"
            };
            const texte = explications[indice] || "";
            document.getElementById("explicationIndice").textContent = texte;
        }

        // Fonction afficherScenario d'affichage d'un scénario donné
        function afficherScenario(fichierGeojson, annee, id_indice) {
            // Supprimer la couche précédente si elle existe
            if (scenarioLayerGroup) {
                carte.removeLayer(scenarioLayerGroup);
            }
            const [couleur_min, couleur_max] = getColorPaletteForIndice(id_indice);
            fetch(fichierGeojson)
                .then(response => response.json())
                .then(data => {
                    // const features = data.features.filter(f => f.properties.Annee === annee);
                    const features = data.features.filter(f => f.properties[id_indice] !== undefined);
                    // Calcul dynamique des valeurs min et max
                    let minVal = Infinity;
                    let maxVal = -Infinity;

                    features.forEach(f => {
                        const val = f.properties[id_indice];
                        if (val !== undefined && !isNaN(val)) {
                            minVal = Math.min(minVal, val);
                            maxVal = Math.max(maxVal, val);
                        }
                    });
                    const [min2Val, max2Val] = getMinMaxIndice(id_indice);

                    // Affichage console
                    console.log(`Indice : ${id_indice}`);
                    console.log(`→ Valeur min : ${minVal}`);
                    console.log(`→ Valeur max : ${maxVal}`);

                    const newLayer = L.layerGroup();

                    features.forEach(f => {
                        const lat = f.geometry.coordinates[1];
                        const lon = f.geometry.coordinates[0];
                        const val = f.properties[id_indice];
                        const squareCoords = getSquareAround(lat, lon, 8000);
                        const color = getColor(val, min2Val, max2Val, couleur_min, couleur_max);

                        const poly = L.polygon(squareCoords, {
                            color: color,
                            fillColor: color,
                            fillOpacity: 0.60,
                            weight: 0,
                            pane: 'scenarioPane'
                        });
                        poly.addTo(newLayer);
                    });

                    // Mise à jour de la légende
                    legend.update({
                        id_indice: id_indice,
                        min: min2Val,
                        max: max2Val,
                        colorMin: couleur_min,
                        colorMax: couleur_max
                    });
                    // On supprime la légende si l'indice est les TRI
                    if (id_indice == "ZonesInnondables") {
                        legend.update()
                    }
                    newLayer.addTo(carte);
                    scenarioLayerGroup = newLayer;
                })
                .catch(err => {
                    console.error("Erreur lors du chargement du fichier :", err);
                });
        }

        //Ajout du réseau ferré national Rfn
        let LignesRfnStyle = {
            "color": "#04354f",
            "weight": 1.2,
            "opacity": 0.95
        }
        let LignesRfn = L.geoJSON(lignesrfnJSON, {
            style: LignesRfnStyle,
            pane: 'reseauPane'
        }).addTo(carte)

        // Activer/Desactiver le réseau ferré national
        // Ciblage de la checkbox
        const lignesCheckbox = document.getElementById('checkboxLignes');
        // Activation/désactivation de la couche
        lignesCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                carte.addLayer(LignesRfn);
            } else {
                carte.removeLayer(LignesRfn);
            }
        });

        // Affiche les infrastructures 
        let infraLayer = null; // Couche des infrastructures

        // Fonction de style pour pour les lignes (ouvrages en terre) 
        function styleInfra(feature, estRisque = false) {
            if (feature.geometry.type === "LineString" || feature.geometry.type === "MultiLineString") {
                return {
                    color: "#A52A2A",
                    weight: estRisque ? 6 : 3,
                    opacity: 0.5
                };
            }
            return null;
        }

        // Fonction de style pour pour les points (autres infrastructures) 
        function pointToLayerInfra(feature, latlng, estRisque = false) {
            const value = document.getElementById("infraSelect").value;

            let color;
            if (value === "gares") color = "#0077b6"; // 
            else if (value === "ouvrages") color = "#f67d15";
            else if (value === "ponts_route") color = "#e43ea9";
            else if (value === "passerelles") color = "#9008a0";
            else color = "#0077b6";

            const rayon = estRisque ? 6 : 3;

            return L.circleMarker(latlng, {
                radius: rayon,
                fillColor: color,
                color: color,
                weight: 1,
                opacity: 1,
                fillOpacity: 0.7,
                pane: 'infraPane'
            });
        }



        function afficherInfrastructure(fichier) {
            if (fichier == null) return;
            fetch(fichier)
                .then(res => res.json())
                .then(data => {
                    if (infraLayer) {
                        carte.removeLayer(infraLayer);
                        infraLayer = null;
                    }

                    infraLayer = L.geoJSON(data, {
                        pane: 'infraPane',
                        style: function (feature) {
                            return styleInfra(feature, false);
                        },
                        pointToLayer: function (feature, latlng) {
                            return pointToLayerInfra(feature, latlng, false);
                        },
                        onEachFeature: function (feature, layer) {
                            if (feature.properties) {
                                const nom = feature.properties.nom || feature.properties.libelle || "Infrastructures";
                                layer.bindPopup(`<strong>${nom}</strong>`);
                            }
                        }
                    }).addTo(carte);
                });
        }

        // Affiche les Territoires à risque d'inondation
        let inondLayer = null; // Couche des inondations

        function afficherInondation(fichier) {
            fetch(fichier)
                .then(res => res.json())
                .then(data => {
                    // Supprime l'ancienne couche si elle existe
                    if (inondLayer) {
                        carte.removeLayer(inondLayer);
                        inondLayer = null;
                    }
                    // Crée la nouvelle couche
                    inondLayer = L.geoJSON(data, {
                        pane: 'infraPane',
                        style: {
                            fillColor: "#c3b4d3",
                            color: "#5e5568",
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.6
                        }
                    }).addTo(carte);
                });
        }

        // Cette fonction zoneARisque stocke les points à risque concernant un indice, d'une année, d'un fichier geojson, au dessus d'un seuil précisé
        async function zoneARisque(fichierGeojson, annee, indice, seuil) {
            try {
                const response = await fetch(fichierGeojson);
                const data = await response.json();

                // Filtrer les points correspondant à l'année et au seuil
                const featuresFiltrees = data.features.filter(feature =>
                    feature.properties &&
                    feature.properties[indice] !== undefined &&
                    feature.properties[indice] >= seuil
                );

                return featuresFiltrees;

            } catch (error) {
                console.error(`Erreur lors du chargement ou du filtrage de ${fichierGeojson} :`, error);
                return [];
            }
        }

        // Cette fonction charge les infrastructures et affiche uniquement celles présentes dans un rayon de 4km d'une zone à risque définie par un indice et un seuil
        // Traite les zones innondables à part, en vérifiant l'intersection avec les zones
        async function chargerInfraARisque(geojsonInfra, fichierScenar, annee, indice, seuil) {
            const rayon = 4000;

            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371000; // rayon de la terre en mètres
                const dLat = (lat2 - lat1) * Math.PI / 180;
                const dLon = (lon2 - lon1) * Math.PI / 180;
                const a = Math.sin(dLat / 2) ** 2 +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon / 2) ** 2;
                return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            }

            try {
                let zones = [];

                if (indice !== "ZonesInnondables") {
                    zones = await zoneARisque(fichierScenar, annee, indice, seuil);
                } else {
                    const response = await fetch("data-METEO/n_tri_s.geojson");
                    const data = await response.json();
                    zones = data.features;
                }

                // Prépare les bbox des zones (optimisation de temps de calcul pour les TRI)
                const zonesAvecBbox = zones.map(zone => ({
                    feature: zone,
                    bbox: turf.bbox(zone) // [minX, minY, maxX, maxY]
                }));

                const res = await fetch(geojsonInfra);
                const dataInfra = await res.json();

                let infraARisque = [];

                if (indice === "ZonesInnondables") {
                    console.time("filtrage TRI"); // timer pour savoir le temps de calcul des infra dans les tri

                    infraARisque = dataInfra.features.filter(feature => {
                        if (!feature.geometry) return false;

                        const type = feature.geometry.type;
                        // Pour les TRI, on ne teste la présence dans une zone TRI que si elle fait partie d'une bbox englobante
                        if (type === "Point") {
                            const [lon, lat] = feature.geometry.coordinates;

                            const candidats = zonesAvecBbox.filter(z => {
                                const [minX, minY, maxX, maxY] = z.bbox;
                                return lon >= minX && lon <= maxX && lat >= minY && lat <= maxY;
                            });

                            return candidats.some(z => turf.booleanPointInPolygon(feature, z.feature));
                        }
                        if (type === "LineString" || type === "MultiLineString") {
                            const bboxFeature = turf.bbox(feature);
                            const bboxPolygon = turf.bboxPolygon(bboxFeature);

                            const candidats = zonesAvecBbox.filter(z => {
                                const [minX, minY, maxX, maxY] = z.bbox;
                                return !(bboxFeature[2] < minX || bboxFeature[0] > maxX ||  // disjoint sur X
                                    bboxFeature[3] < minY || bboxFeature[1] > maxY);   // disjoint sur Y
                            });

                            return candidats.some(z => turf.booleanIntersects(feature, z.feature));
                        }
                        return false;
                    });

                    console.timeEnd("filtrage TRI");
                }
                else {
                    // Méthode classique pour les autres indices
                    infraARisque = dataInfra.features.filter(feature => {
                        const pt = feature.properties.geo_point_2d;
                        return zones.some(z => {
                            const [zLon, zLat] = z.geometry.coordinates;
                            return haversineDistance(pt.lat, pt.lon, zLat, zLon) < rayon;
                        });
                    });
                }

                const couche = {
                    ...dataInfra,
                    features: infraARisque
                };

                if (infraLayer) {
                    carte.removeLayer(infraLayer);
                    infraLayer = null;
                }

                infraLayer = L.geoJSON(couche, {
                    pane: 'infraPane',
                    style: feature => styleInfra(feature, true),
                    pointToLayer: (feature, latlng) => pointToLayerInfra(feature, latlng, true),
                    onEachFeature: (feature, layer) => {
                        if (feature.properties) {
                            const nom = feature.properties.libelle || 'Non nommé, id réseau :' + feature.properties.idreseau;
                            layer.bindPopup(`<strong>${nom}</strong>`);
                            
                        }
                    }
                }).addTo(carte);
                // On remplace les libelle null par l'idreseau qui je suppose est unique, pour éviter d'oublier les infrastructures qui ont un libelle : null 
                const libellesUniques = new Set(
                    infraARisque.map(f => f.properties.libelle !== null
                        ? f.properties.libelle
                        : `Non nommé, id réseau :${f.properties.idreseau}`)
                );
                const select = document.getElementById("infraSelect");
                const infra_nom = select.options[select.selectedIndex].text;
                const indiceSelect = document.getElementById("indiceSelect");
                const indiceTexte = indiceSelect.options[indiceSelect.selectedIndex].text;
                const seuil1 = parseFloat(document.getElementById("seuilValue").value);

                if (indiceSelect.value != "ZonesInnondables"){
                    document.getElementById("nombreOuvrages").textContent =
                        libellesUniques.size + ' ' + infra_nom + ' dont l’indice ' + indiceTexte + ' est supérieur à ' + seuil1 + ' :';                    
                }
                else {
                    document.getElementById("nombreOuvrages").textContent =
                        libellesUniques.size + ' ' + infra_nom + ' en ' + indiceTexte;
                }

                console.log(infraARisque);
                const listeElem = document.getElementById("listeOuvrages");
                listeElem.innerHTML = "";

                libellesUniques.forEach(lib => {
                    const li = document.createElement("li");
                    li.textContent = lib;
                    listeElem.appendChild(li);
                });

            } catch (err) {
                console.error("Erreur dans chargerInfraARisque :", err);
            }
        }

        // Récupère l'infrastructure selectionnée, renvoie le fichier
        function getSelectedInfraInfo() {
            const value = document.getElementById("infraSelect").value;
            switch (value) {
                case 'gares':
                    return { fichier: 'data-SNCF/liste-des-gares.geojson' };
                case 'ouvrages':
                    return { fichier: 'data-SNCF/liste-ouvrages-en-terre.geojson' };
                case 'ponts_route':
                    return { fichier: 'data-SNCF/liste-des-ponts-route.geojson' };
                case 'passerelles':
                    return { fichier: 'data-SNCF/liste-des-passerelles.geojson' };
                default:
                    return null;
            }
        }

        // Récupère le scénario selectionné, renvoie le fichier et l'année d'intérêt
        function getSelectedScenarioInfo() {
            const scenario = document.querySelector('input[name="scenario"]:checked');
            if (!scenario) return "";

            const value = scenario.value;
            switch (value) {
                case 'actuel':
                    return { fichier: 'data-METEO/indicesDRIAS2023moyenne.geojson', annee: 2005 };
                case '2030':
                    return { fichier: 'data-METEO/indicesDRIAS2030moyenne.geojson', annee: 2037 };
                case '2050':
                    return { fichier: 'data-METEO/indicesDRIAS2050moyenne.geojson', annee: 2053 };
                case '2100':
                    return { fichier: 'data-METEO/indicesDRIAS2100moyenne.geojson', annee: 2098 };
                default:
                    return null;
            }
        }

        // Affiche l'indice en fonction du scénario selectionné
        document.querySelectorAll('input[name="scenario"]').forEach(radio => {
            radio.addEventListener('change', function () {
                document.getElementById("explicationIndice").textContent = "";
                document.getElementById("nombreOuvrages").textContent = '';
                document.getElementById("listeOuvrages").innerHTML = "";
                const scenario_info = getSelectedScenarioInfo();
                const selectedIndice = document.getElementById("indiceSelect").value;
                const infra_info = getSelectedInfraInfo(); // Récupère LE FICHIER infrastructure
                const infra = document.getElementById("infraSelect").value;
                const indice = document.getElementById("indiceSelect").value; // Recupère l'indice
                afficherExplicationIndice(indice); // Affiche l’explication
                const seuil = parseFloat(document.getElementById("seuilValue").value);
                if (scenario_info && selectedIndice != "") {
                    afficherScenario(scenario_info.fichier, scenario_info.annee, selectedIndice);
                    if (selectedIndice && infra && seuil != 0) {
                        chargerInfraARisque(infra_info.fichier, scenario_info.fichier, scenario_info.annee, indice, seuil);
                    }
                }
                if (selectedIndice == "") { // si aucun indice n'est sélectionné
                    console.log("Aucun indice sélectionné");
                    // mettre en rouge le texte de l'indice
                    document.getElementById("explicationIndice").textContent = "Veuillez sélectionner un indice";
                    document.getElementById("explicationIndice").style.color = "red";
                }
            });
        });

        // Affiche le scénario en fonction de l'indice sélectionné, (affiche le détail/explication de l'indice)
        document.getElementById("indiceSelect").addEventListener("change", () => {
            const indice = document.getElementById("indiceSelect").value;
            afficherExplicationIndice(indice); // Affiche l’explication
            if (indice == "ZonesInnondables") {
                legend.update();
                document.querySelectorAll('#SelectionScenarios input[type="radio"]').forEach(cb => cb.checked = false);
                if (scenarioLayerGroup) carte.removeLayer(scenarioLayerGroup);
                afficherInondation("data-METEO/n_tri_s.geojson")
                document.getElementById("explication-seuil").textContent = "Les territoires à risque d'inondation ne nécessitent pas de seuil, sélectionnez une infrastructure puis cliquez Afficher pour voir les infrastructures à risque";
                const infra_info = getSelectedInfraInfo(); // Récupère infrastructure
                const scenario_info = getSelectedScenarioInfo();
                chargerInfraARisque(infra_info.fichier, scenario_info.fichier, scenario_info.annee, indice, 0)

            }
            else {
                document.getElementById("explication-seuil").textContent = "Indiquez une valeur de seuil concernant l'indice sélectionné pour afficher les infrastructures que vous définissez à risque";
                const info = getSelectedScenarioInfo();
                if (inondLayer) carte.removeLayer(inondLayer);
                if (!info) {
                    // console.log("Aucun scénario sélectionné");
                    if (indice!="") {
                        console.log(indice);
                        document.getElementById("explicationIndice").textContent = "Veuillez sélectionner un scénario climatique";
                    document.getElementById("explicationIndice").style.color = "red";
                    }
                    else{
                        document.getElementById("explicationIndice").textContent = "Veuillez sélectionner un indice";
                    document.getElementById("explicationIndice").style.color = "red";
                    }
                };
                if (indice=="") {
                        document.getElementById("explicationIndice").textContent = "Veuillez sélectionner un indice";
                    document.getElementById("explicationIndice").style.color = "red";
                }
                
                afficherScenario(info.fichier, info.annee, indice);
                document.getElementById("nombreOuvrages").textContent = '';
                document.getElementById("listeOuvrages").innerHTML = "";
                // remet à zéro le seuil
                document.getElementById("seuilValue").value = 0;
                // remove le pane des infra a risques
                if (infraLayer) {
                    carte.removeLayer(infraLayer);
                    infraLayer = null;
                }
            }
        });

        // Affiche les infrastructures sélectionnées depuis la rubrique Réseau
        document.getElementById("infraSelect").addEventListener("change", () => {
            const infra = document.getElementById("infraSelect").value;
            const info = getSelectedInfraInfo();
            if (infra == "") { // A la non selection d'indice (click sur "Séléctionner")
                document.getElementById("nombreOuvrages").textContent = "";
                document.getElementById("listeOuvrages").innerHTML = "";
                console.log(infraLayer);

                // Supprime l'ancienne couche si elle existe            
                if (infraLayer) {
                    console.log("Supprimer l'ancienne couche infraLayer");
                    carte.removeLayer(infraLayer);
                    infraLayer = null;
                }
            }

            // Affiche les infrastructures à risque si le seuil n'est pas à 0 et qu'un indice est sélectionné
            const selectedIndice = document.getElementById("indiceSelect").value;
            const seuil = parseFloat(document.getElementById("seuilValue").value);
            if (selectedIndice && infra != "" && seuil != 0) {
                const scenario_info = getSelectedScenarioInfo();
                const indice = document.getElementById("indiceSelect").value; // Recupère l'indice
                chargerInfraARisque(info.fichier, scenario_info.fichier, scenario_info.annee, indice, seuil);
                document.getElementById("OuvragesArisqueDetecte").textContent = "";
            }
            else {
                afficherInfrastructure(info.fichier)
                document.getElementById("nombreOuvrages").textContent = '';
                document.getElementById("listeOuvrages").innerHTML = "";
            }
        });

        // Gère le bouton "Afficher" de l'affichage des ouvrages seuillés
        document.getElementById("afficherBtn").addEventListener("click", async () => {
            const scenario_info = getSelectedScenarioInfo(); // Récupère scénario + année
            const infra_info = getSelectedInfraInfo(); // Récupère infrastructure
            const select = document.getElementById("infraSelect");
            const infra_nom = select.options[select.selectedIndex].text;// récupère le contenu et non la value 
            const indice = document.getElementById("indiceSelect").value; // Recupère l'indice
            const seuil = parseFloat(document.getElementById("seuilValue").value);
            document.getElementById("OuvragesArisqueDetecte").textContent = "";

            if (infraSelect.value == "") {
                document.getElementById("OuvragesArisqueDetecte").style.color = "red";
                document.getElementById("OuvragesArisqueDetecte").textContent = "Veuillez sélectionner un une infrastructure";
                return;
            }
            // Supprime l'ancienne couche si elle existe
            if (infraLayer) {
                carte.removeLayer(infraLayer);
                infraLayer = null;
            }
            // Si on veut afficher les tri sans avoir sélectionné de scénario, corrige l'erreur cannot read properties of null pour le fichier scenario
            if (indice == "ZonesInnondables" && !scenario_info) {
                // scenario_info = { fichier: "data-METEO/indicesDRIAS2050moyenne.geojson", annee: 0 }; // On met une année fictive
            }
            // Appelle ta fonction de filtrage/affichage
            await chargerInfraARisque(infra_info.fichier, scenario_info.fichier, scenario_info.annee, indice, seuil);
        });

        // Gère le bouton nettoyer carte
        function nettoyerCarte() {
            carte.eachLayer(function (layer) {
                // Ne  supprime pas le fond de carte
                if (layer instanceof L.TileLayer) return;
                // Supprime toute autre couche
                carte.removeLayer(layer);
            });

            // Réinitialise l'affichage
            legend.update();
            document.getElementById("nombreOuvrages").textContent = '';
            document.getElementById("listeOuvrages").innerHTML = "";
            document.querySelectorAll('#SelectionReseau input[type="checkbox"]').forEach(cb => cb.checked = false);
            document.querySelectorAll('#SelectionScenarios input[type="radio"]').forEach(cb => cb.checked = false);
            document.getElementById("infraSelect").selectedIndex = 0;
            document.getElementById("indiceSelect").selectedIndex = 0;
        }
        document.getElementById("clearcarte").addEventListener("click", nettoyerCarte);

        // Gère le bouton de la fenetre d'intro
        document.getElementById("closeModalBtn").addEventListener("click", () => {
            document.getElementById("modalIntro").style.display = "none";
        });
        // Gère le bouton d'information sur le header
        document.getElementById("infoBtn").addEventListener("click", () => {
            document.getElementById("modalIntro").style.display = "flex";
        });

    </script>
</body>

</html>
<!DOCTYPE html>
<html lang="fr">   